#include "ui_update.h"
#include "signature_scan.h"
#include <gtk/gtk.h>
#include <stdio.h>
#include <time.h>
#include <windows.h>
// --- Helper: Check Time ---
gboolean needs_update_today(void) {
    if (strcmp(last_update_time, "Never") == 0) return TRUE;
    
    char today[16];
    time_t now = time(NULL);
    struct tm *tm_info = localtime(&now);
    strftime(today, sizeof(today), "%Y-%m-%d", tm_info);

    return strncmp(last_update_time, today, 10) != 0;
}
// --- Helper: Refresh Label ---
gboolean refresh_last_update_label(gpointer data) {
    // Handle both direct AppState* or GSource data
    AppState *app = (AppState *)data;
    // Safety check
    if (!app || !app->last_update_label) return G_SOURCE_REMOVE;

    char markup[256];
    snprintf(markup, sizeof(markup), 
        "Last Updated: <span weight='bold'>%s</span>", 
        last_update_time);
    
    gtk_label_set_markup(GTK_LABEL(app->last_update_label), markup);
    
    return G_SOURCE_REMOVE;
}
// --- Thread Logic ---
static gpointer update_worker_thread(gpointer data) {
    update_signature_db("signatures.db");
    return NULL;
}

gpointer silent_update_thread(gpointer data) {
    AppState *app = (AppState *)data;

    int result = update_signature_db("signatures.db");
    if (result == 0) {
        time_t now = time(NULL);
        struct tm *tm_info = localtime(&now);
        strftime(last_update_time, sizeof(last_update_time), "%Y-%m-%d %H:%M", tm_info);
        save_settings();

        if (app) {
            g_idle_add((GSourceFunc)refresh_last_update_label, app);
        }
    }
    return NULL;
}

gboolean auto_update_timer(gpointer data) {
    AppState *app = (AppState *)data;
    if (!app) return G_SOURCE_CONTINUE;

    g_thread_new("SilentUpdater", silent_update_thread, app);
    return G_SOURCE_CONTINUE;
}
// --- Manual Update UI ---
static GtkWidget *update_dialog = NULL;
static GtkWidget *update_progress_bar = NULL;
static GtkWidget *update_status_label = NULL;

static gboolean destroy_update_dialog_cb(gpointer data) {
    if (data) {
        gtk_window_destroy(GTK_WINDOW(data));
    }
    return G_SOURCE_REMOVE;
}

static gboolean check_manual_progress(gpointer user_data) {
    if (!update_dialog) return G_SOURCE_REMOVE;

    double fraction = (double)update_progress / 100.0;
    if (fraction > 1.0) fraction = 1.0;
    if (fraction < 0) fraction = 0.0;

    gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(update_progress_bar), fraction);
    
    char buf[64];
    if (update_progress < 100 && update_progress >= 0) {
        snprintf(buf, 64, "Downloading... %d%%", update_progress);
        gtk_label_set_text(GTK_LABEL(update_status_label), buf);
    }

    if (update_progress == 101) {
        gtk_label_set_text(GTK_LABEL(update_status_label), "Update Complete!");
        
        time_t now = time(NULL);
        struct tm *tm_info = localtime(&now);
        strftime(last_update_time, sizeof(last_update_time), "%Y-%m-%d %H:%M", tm_info);
        save_settings();

        // Retrieve app pointer to refresh label
        AppState *app = (AppState *)g_object_get_data(G_OBJECT(update_dialog), "app_ptr");
        if (app) refresh_last_update_label(app);

        g_timeout_add_seconds(1, destroy_update_dialog_cb, update_dialog);
        update_dialog = NULL;
        return G_SOURCE_REMOVE;

    }
    
    if (update_progress == -1) {
        gtk_label_set_text(GTK_LABEL(update_status_label), "Update Failed.");
        return G_SOURCE_REMOVE;
    }

    return G_SOURCE_CONTINUE;
}
// NO static - used by ui_views.c
void on_update_clicked(GtkButton *btn, gpointer user_data) {
    AppState *app = (AppState *)user_data;
    
    update_dialog = gtk_window_new();
    gtk_window_set_title(GTK_WINDOW(update_dialog), "Database Update");
    gtk_window_set_modal(GTK_WINDOW(update_dialog), TRUE);
    gtk_window_set_transient_for(GTK_WINDOW(update_dialog), GTK_WINDOW(app->window));
    gtk_window_set_default_size(GTK_WINDOW(update_dialog), 300, 150);
    
    // Store app pointer for use in completion callback
    g_object_set_data(G_OBJECT(update_dialog), "app_ptr", app);

    GtkWidget *box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 20);
    gtk_widget_set_margin_top(box, 20);
    gtk_widget_set_margin_bottom(box, 20);
    gtk_widget_set_margin_start(box, 20);
    gtk_widget_set_margin_end(box, 20);
    gtk_window_set_child(GTK_WINDOW(update_dialog), box);

    update_status_label = gtk_label_new("Initializing...");
    gtk_box_append(GTK_BOX(box), update_status_label);

    update_progress_bar = gtk_progress_bar_new();
    gtk_box_append(GTK_BOX(box), update_progress_bar);

    gtk_window_present(GTK_WINDOW(update_dialog));
    
    update_progress = 0;
    g_thread_new("Updater", update_worker_thread, NULL);
    g_timeout_add(100, check_manual_progress, NULL);
}
// NO static - used by ui_views.c
gboolean on_auto_update_toggled(GtkSwitch *widget, gboolean state, gpointer user_data) {
    auto_update_enabled = state;
    save_settings();
    return FALSE; // Allow default signal propagation
}