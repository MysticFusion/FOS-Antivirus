#include "ui_scan.h"
#include "scan_bridge.h"
#include "scan_core.h"
#include "signature_scan.h"
#include "ui_update.h" 
#include "ui_history.h"
#include <gtk/gtk.h>
#include <stdio.h>
// --- Context ---
typedef struct {
    AppState *app;
    char *scan_arg;
} ScanAfterUpdateCtx;
// --- Function Prototypes ---
gpointer scan_worker_thread(gpointer user_data);
static gpointer update_then_scan_thread(gpointer data);
static gboolean start_scan_from_idle(gpointer data);
static gboolean on_scan_progress_tick(gpointer user_data);
static void on_folder_selected(GObject *source_object, GAsyncResult *res, gpointer user_data);
static void on_stop_scan(GtkButton *btn, gpointer user_data);
// 1. SCANNING LOGIC
static gboolean on_scan_progress_tick(gpointer user_data) {
    AppState *app = (AppState *)user_data;
    g_mutex_lock(&global_scan_ctx.mutex);
    
    char raw_file[256];
    strncpy(raw_file, global_scan_ctx.current_file, 255);
    raw_file[255] = '\0';
    bool still_running = global_scan_ctx.is_running;
    int final_files = global_scan_ctx.files_scanned;
    int final_threats = global_scan_ctx.threats_found;
    g_mutex_unlock(&global_scan_ctx.mutex);
    // Convert Windows path to UTF-8
    GError *conv_err = NULL;
    char *utf8_file = g_locale_to_utf8(raw_file, -1, NULL, NULL, &conv_err);
    
    char file_label[512];
    if (utf8_file) {
        // Just show the filename part to keep UI clean, or truncate start
        size_t len = strlen(utf8_file);
        if (len > 50) 
            snprintf(file_label, sizeof(file_label), "Scanning: ...%s", &utf8_file[len - 50]);
        else 
            snprintf(file_label, sizeof(file_label), "Scanning: %s", utf8_file);
        g_free(utf8_file);
    } else {
        snprintf(file_label, sizeof(file_label), "Scanning: [System File]");
        if (conv_err) g_error_free(conv_err);
    }
    
    gtk_label_set_text(GTK_LABEL(app->progress_label), file_label);
    gtk_progress_bar_pulse(GTK_PROGRESS_BAR(app->progress_bar));

    if (!still_running) {
        gchar *f_txt = g_strdup_printf("Files Scanned: %d", final_files);
        gchar *t_txt = g_strdup_printf("Threats Found: %d", final_threats);
        gtk_label_set_text(GTK_LABEL(app->result_files_label), f_txt);
        gtk_label_set_text(GTK_LABEL(app->result_threats_label), t_txt);
        g_free(f_txt); g_free(t_txt);
        reload_history_view(app);
        gtk_stack_set_visible_child_name(GTK_STACK(app->stack), "complete");
        return FALSE; 
    }
    return TRUE; 
}

gpointer scan_worker_thread(gpointer user_data) {
    char *mode = (char *)user_data; 
    const char *db_path = "signatures.db"; 

    g_mutex_lock(&global_scan_ctx.mutex);
    global_scan_ctx.is_running = true;
    global_scan_ctx.stop_requested = false;
    global_scan_ctx.files_scanned = 0;
    global_scan_ctx.threats_found = 0;
    memset(global_scan_ctx.current_file, 0, 256);
    g_mutex_unlock(&global_scan_ctx.mutex);

    if (strcmp(mode, "QUICK_SCAN") == 0) {
        GList *paths = get_quick_scan_paths();
        GList *iter = paths;
        while (iter != NULL) {
            char *folder_path = (char *)iter->data;
            g_mutex_lock(&global_scan_ctx.mutex);
            if (global_scan_ctx.stop_requested) { 
                g_mutex_unlock(&global_scan_ctx.mutex); 
                break; 
            }
            g_mutex_unlock(&global_scan_ctx.mutex);
            signature_scan(db_path, folder_path);
            iter = iter->next;
        }
        g_list_free_full(paths, g_free);
    } else if (strcmp(mode, "FULL_SYSTEM") == 0) {
        signature_scan(db_path, "C:\\Users"); 
    } else {
        signature_scan(db_path, mode);
    }

    g_mutex_lock(&global_scan_ctx.mutex);
    global_scan_ctx.is_running = false;
    g_mutex_unlock(&global_scan_ctx.mutex);
    g_free(mode); 
    return NULL;
}

static gboolean start_scan_from_idle(gpointer data) {
    ScanAfterUpdateCtx *ctx = (ScanAfterUpdateCtx *)data;
    gtk_label_set_text(GTK_LABEL(ctx->app->progress_label), "Initializing...");
    g_thread_new("Scanner", scan_worker_thread, ctx->scan_arg); 
    g_free(ctx);
    return G_SOURCE_REMOVE;
}

static gpointer update_then_scan_thread(gpointer data) {
    ScanAfterUpdateCtx *ctx = (ScanAfterUpdateCtx *)data;
    int res = update_signature_db("signatures.db");
    if (res == 0) {
        time_t now = time(NULL);
        struct tm *tm_info = localtime(&now);
        strftime(last_update_time, sizeof(last_update_time), "%Y-%m-%d %H:%M", tm_info);
        save_settings();
        g_idle_add((GSourceFunc)refresh_last_update_label, ctx->app);
    }
    g_idle_add(start_scan_from_idle, ctx);
    return NULL;
}

void start_scan_logic(AppState *app, char *path_or_mode) {
    char *arg = g_strdup(path_or_mode);  // Thread owns this

    gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(app->progress_bar), 0.0);
    gtk_stack_set_visible_child_name(GTK_STACK(app->stack), "progress");

    if (auto_update_enabled && needs_update_today()) {
        gtk_label_set_text(GTK_LABEL(app->progress_label), "Checking for updates...");

        ScanAfterUpdateCtx *ctx = g_new0(ScanAfterUpdateCtx, 1);
        ctx->app = app;
        ctx->scan_arg = arg;  // PASS DUPLICATED STRING

        g_thread_new("UpdateThenScan", update_then_scan_thread, ctx);
    } else {
        gtk_label_set_text(GTK_LABEL(app->progress_label), "Initializing...");

        g_thread_new("Scanner", scan_worker_thread, arg); // PASS DUPLICATED STRING
    }

    g_timeout_add(100, on_scan_progress_tick, app);
}
// 2. VIEW CREATORS
static void on_folder_selected(GObject *source_object, GAsyncResult *res, gpointer user_data) {
    GtkFileDialog *dialog = GTK_FILE_DIALOG(source_object);
    AppState *app = (AppState *)user_data;
    GError *error = NULL;

    GFile *folder = gtk_file_dialog_select_folder_finish(dialog, res, &error);

    if (folder != NULL) {
        char *path = g_file_get_path(folder);
        if (path) {
            start_scan_logic(app, path); 
        }
        g_object_unref(folder);
    } else {
        if (error) g_error_free(error);
    }
}

static void on_browse_clicked(GtkButton *btn, gpointer user_data) {
    AppState *app = (AppState *)user_data;
    GtkFileDialog *dialog = gtk_file_dialog_new();
    gtk_file_dialog_set_title(dialog, "Select Folder to Scan");
    gtk_file_dialog_select_folder(dialog, GTK_WINDOW(app->window), NULL, on_folder_selected, app);
    g_object_unref(dialog);
}

static void on_back_home(GtkButton *btn, gpointer user_data) {
    gtk_stack_set_visible_child_name(GTK_STACK(((AppState*)user_data)->stack), "dashboard");
}

GtkWidget *create_advanced_scan_view(AppState *app) {
    GtkWidget *view = gtk_box_new(GTK_ORIENTATION_VERTICAL, 20);
    gtk_widget_set_margin_start(view, 30); gtk_widget_set_margin_top(view, 30); gtk_widget_set_margin_end(view, 30);
    
    GtkWidget *lbl = gtk_label_new(NULL);
    gtk_label_set_markup(GTK_LABEL(lbl), "<span font='28px' weight='bold'>Advanced Scan</span>");
    gtk_widget_set_halign(lbl, GTK_ALIGN_START);
    gtk_box_append(GTK_BOX(view), lbl);

    GtkWidget *custom_card = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 20);
    gtk_widget_add_css_class(custom_card, "dashboard-card-bg");
    gtk_widget_set_size_request(custom_card, -1, 80);
    
    gtk_box_append(GTK_BOX(custom_card), gtk_label_new("  Custom Scan (Select Directory)"));
    GtkWidget *sp1 = gtk_label_new(""); gtk_widget_set_hexpand(sp1, TRUE); gtk_box_append(GTK_BOX(custom_card), sp1);
    
    GtkWidget *sel_btn = gtk_button_new_with_label("Browse Files...");
    gtk_widget_add_css_class(sel_btn, "scan-btn"); gtk_widget_set_margin_end(sel_btn, 20);
    g_signal_connect(sel_btn, "clicked", G_CALLBACK(on_browse_clicked), app);
    gtk_box_append(GTK_BOX(custom_card), sel_btn);

    gtk_box_append(GTK_BOX(view), custom_card);
    GtkWidget *back_btn = gtk_button_new_with_label("Back");
    gtk_widget_set_halign(back_btn, GTK_ALIGN_START);
    gtk_widget_add_css_class(back_btn, "flat-button");
    g_signal_connect(back_btn, "clicked", G_CALLBACK(on_back_home), app);
    gtk_box_append(GTK_BOX(view), back_btn);

    return view;
}

static void on_stop_scan(GtkButton *btn, gpointer user_data) {
    g_mutex_lock(&global_scan_ctx.mutex);
    global_scan_ctx.stop_requested = true;
    g_mutex_unlock(&global_scan_ctx.mutex);
}
// --- FIXED PROGRESS VIEW (Card-based, Center aligned, Ellipsized) ---
GtkWidget *create_scanner_progress_view(AppState *app) {
    GtkWidget *view = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    gtk_widget_set_halign(view, GTK_ALIGN_CENTER);
    gtk_widget_set_valign(view, GTK_ALIGN_CENTER);
    // Card Container
    GtkWidget *card = gtk_box_new(GTK_ORIENTATION_VERTICAL, 20);
    gtk_widget_add_css_class(card, "dashboard-card-bg");
    // Ensure fixed size so it doesn't jump
    gtk_widget_set_size_request(card, 500, 300);
    gtk_widget_set_valign(card, GTK_ALIGN_CENTER); 
    // Internal padding box
    GtkWidget *inner = gtk_box_new(GTK_ORIENTATION_VERTICAL, 25);
    gtk_widget_set_margin_top(inner, 40);
    gtk_widget_set_margin_bottom(inner, 40);
    gtk_widget_set_margin_start(inner, 40);
    gtk_widget_set_margin_end(inner, 40);
    // Spinner
    GtkWidget *spinner = gtk_spinner_new();
    gtk_widget_set_size_request(spinner, 48, 48);
    gtk_widget_set_halign(spinner, GTK_ALIGN_CENTER);
    gtk_spinner_start(GTK_SPINNER(spinner));
    gtk_box_append(GTK_BOX(inner), spinner);
    // Label (Ellipsized)
    app->progress_label = gtk_label_new("Initializing...");
    gtk_widget_set_halign(app->progress_label, GTK_ALIGN_CENTER);
    // CRITICAL FIX: Cut off text if too long
    gtk_label_set_ellipsize(GTK_LABEL(app->progress_label), PANGO_ELLIPSIZE_END);
    gtk_label_set_max_width_chars(GTK_LABEL(app->progress_label), 45); 
    gtk_widget_set_size_request(app->progress_label, 420, -1);
    gtk_box_append(GTK_BOX(inner), app->progress_label);
    // Progress Bar
    app->progress_bar = gtk_progress_bar_new();
    gtk_widget_set_size_request(app->progress_bar, 350, 10);
    gtk_widget_set_halign(app->progress_bar, GTK_ALIGN_CENTER);
    gtk_box_append(GTK_BOX(inner), app->progress_bar);
    // Stop Button
    GtkWidget *stop_btn = gtk_button_new_with_label("Cancel Scan");
    gtk_widget_add_css_class(stop_btn, "destructive-action");
    gtk_widget_set_halign(stop_btn, GTK_ALIGN_CENTER);
    gtk_widget_set_size_request(stop_btn, 140, 38);
    g_signal_connect(stop_btn, "clicked", G_CALLBACK(on_stop_scan), app);
    gtk_box_append(GTK_BOX(inner), stop_btn);
    gtk_box_append(GTK_BOX(card), inner);
    gtk_box_append(GTK_BOX(view), card);
    return view;
}
GtkWidget *create_scan_complete_view(AppState *app) {
    
    GtkWidget *view = gtk_box_new(GTK_ORIENTATION_VERTICAL, 20);
    gtk_widget_set_valign(view, GTK_ALIGN_CENTER);
    gtk_widget_set_halign(view, GTK_ALIGN_CENTER);

    GtkWidget *card = gtk_box_new(GTK_ORIENTATION_VERTICAL, 15);
    gtk_widget_add_css_class(card, "dashboard-card-bg");
    gtk_widget_set_size_request(card, 400, 250);

    GtkWidget *grid = gtk_grid_new();
    gtk_grid_set_row_spacing(GTK_GRID(grid), 10);
    gtk_grid_set_column_spacing(GTK_GRID(grid), 20);
    gtk_widget_set_halign(grid, GTK_ALIGN_CENTER);
    
    app->result_files_label = gtk_label_new("Files Scanned: 0");
    app->result_threats_label = gtk_label_new("Threats Found: 0");
    
    gtk_grid_attach(GTK_GRID(grid), app->result_files_label, 0, 0, 1, 1);
    gtk_grid_attach(GTK_GRID(grid), app->result_threats_label, 0, 1, 1, 1);
    
    gtk_box_append(GTK_BOX(card), grid);

    GtkWidget *home_btn = gtk_button_new_with_label("Back to Dashboard");
    gtk_widget_add_css_class(home_btn, "scan-btn");
    g_signal_connect(home_btn, "clicked", G_CALLBACK(on_back_home), app);
    gtk_box_append(GTK_BOX(card), home_btn);

    gtk_box_append(GTK_BOX(view), card);
    return view;
}