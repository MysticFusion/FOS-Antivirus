#define _CRT_SECURE_NO_WARNINGS
#include "scan_core.h" 
#include "scan_bridge.h"
#include "sha2.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <windows.h>
#include <shlobj.h>
#include <objbase.h>

#define READ_CHUNK (64 * 1024)

// ==========================================
// 1. HELPER FUNCTIONS (Must be defined first)
// ==========================================

// Helper to check if a path exists and is a directory before adding
static void add_path_safe(GList **list, const char *path) {
    DWORD attr = GetFileAttributesA(path);
    if (attr != INVALID_FILE_ATTRIBUTES && (attr & FILE_ATTRIBUTE_DIRECTORY)) {
        // Avoid duplicates if needed, but for now just append
        *list = g_list_append(*list, g_strdup(path));
    }
}

// Internal recursive walker
static void list_path_recursive_internal(const char *base_path, FilePathList *list) {
    WIN32_FIND_DATA find_data;
    char search_path[MAX_PATH];
    
    // Check if stop was requested
    g_mutex_lock(&global_scan_ctx.mutex);
    if (global_scan_ctx.stop_requested) {
        g_mutex_unlock(&global_scan_ctx.mutex);
        return;
    }
    g_mutex_unlock(&global_scan_ctx.mutex);

    // Create search pattern: "C:\Path\*"
    snprintf(search_path, sizeof(search_path), "%s\\*", base_path);
    
    HANDLE h_find = FindFirstFile(search_path, &find_data);
    if (h_find == INVALID_HANDLE_VALUE) return;

    do {
        // Skip "." and ".."
        if (strcmp(find_data.cFileName, ".") == 0 || strcmp(find_data.cFileName, "..") == 0)
            continue;

        char full_path[MAX_PATH];
        snprintf(full_path, sizeof(full_path), "%s\\%s", base_path, find_data.cFileName);

        if (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            // Recursive call
            list_path_recursive_internal(full_path, list);
        } else {
            // It's a file, add to list
            list->paths = g_list_append(list->paths, g_strdup(full_path));
            list->total_files++;
        }

    } while (FindNextFile(h_find, &find_data) != 0);

    FindClose(h_find);
}


// ==========================================
// 2. PUBLIC FUNCTIONS
// ==========================================

// --- SHA-256 Computation ---
int compute_file_sha256(const char *path, unsigned char out_hash[32]) {
    FILE *f = fopen(path, "rb");
    if (!f) return -1;

    unsigned char buf[READ_CHUNK];
    sha256_ctx ctx;
    sha256_init(&ctx);

    size_t r;
    while ((r = fread(buf, 1, sizeof(buf), f)) > 0)
        sha256_update(&ctx, buf, r);

    if (ferror(f)) {
        fclose(f);
        return -1;
    }

    sha256_final(&ctx, out_hash);
    fclose(f);
    return 0;
}

// --- Quick Scan Path Generator ---
GList* get_quick_scan_paths(void) {
    GList *list = NULL;
    char path[MAX_PATH];

    // 1. Hardcoded System Paths
    add_path_safe(&list, "C:\\Windows\\System32");
    add_path_safe(&list, "C:\\Windows\\SysWOW64");
    add_path_safe(&list, "C:\\Windows\\Temp");

    // 2. Environment Variables (%TEMP%)
    if (GetEnvironmentVariableA("TEMP", path, MAX_PATH) > 0) {
        add_path_safe(&list, path);
    }

    // 3. User Specific Shell Folders
    if (SHGetFolderPathA(NULL, CSIDL_STARTUP, NULL, 0, path) == S_OK) 
        add_path_safe(&list, path);
        
    if (SHGetFolderPathA(NULL, CSIDL_APPDATA, NULL, 0, path) == S_OK) 
        add_path_safe(&list, path);
        
    if (SHGetFolderPathA(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, path) == S_OK) 
        add_path_safe(&list, path);

    if (SHGetFolderPathA(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, path) == S_OK) 
        add_path_safe(&list, path);

    if (SHGetFolderPathA(NULL, CSIDL_PERSONAL, NULL, 0, path) == S_OK) 
        add_path_safe(&list, path);

    if (SHGetFolderPathA(NULL, CSIDL_PROFILE, NULL, 0, path) == S_OK) {
        char downloads[MAX_PATH];
        snprintf(downloads, MAX_PATH, "%s\\Downloads", path);
        add_path_safe(&list, downloads);
    }

    return list;
}

// --- Recursive Path Lister Entry Point ---
FilePathList* list_files_recursive(const char *path_to_scan) {
    FilePathList *list = malloc(sizeof(FilePathList));
    if (!list) return NULL;
    
    list->paths = NULL;
    list->total_files = 0;

    list_path_recursive_internal(path_to_scan, list);
    
    return list;
}

void free_filepath_list(FilePathList *list) {
    if (!list) return;
    g_list_free_full(list->paths, g_free);
    free(list);
}