#include <gtk/gtk.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

// Include your backend headers
#include "scan_bridge.h"
#include "signature_scan.h"
#include "scan_core.h"

#define SETTINGS_FILE "settings.conf"

static gboolean auto_update_enabled = TRUE;
static char last_update_time[64] = "Never";

// --- CSS THEMES ---
// REMOVED: "text-align: left" to fix GTK Warnings
static const char *CSS_LIGHT =
    "window { background-color: #FFFFFF; color: #1A202C; }"
    ".sidebar { background-color: #F7FAFC; border-right: 1px solid #E2E8F0; transition: min-width 200ms ease; }"
    ".dashboard-card-bg { background-color: #FFFFFF; border: 1px solid #E2E8F0; border-radius: 12px; }"
    ".protection-card-bg { background-color: #F7FAFC; border-radius: 12px; }"
    
    /* Nav Items */
    ".nav-item { background: transparent; border: none; border-radius: 6px; padding: 10px 12px; color: #4A5568; }"
    ".nav-item:hover { background: #EDF2F7; color: #2D3748; }"
    
    /* Burger Button */
    ".burger-btn { background: transparent; border: none; color: #4A5568; border-radius: 4px; padding: 8px; }"
    ".burger-btn:hover { background: #E2E8F0; color: #1A202C; }"

    /* Action Buttons */
    ".scan-btn { background: #3182CE; color: white; border-radius: 8px; padding: 6px 16px; border: none; }"
    ".scan-btn:hover { background: #2B6CB0; }"
    ".flat-button { background: transparent; border: none; color: #4A5568; border-radius: 4px; padding: 4px; }"
    ".flat-button:hover { background: #EDF2F7; color: #1A202C; }"
    
    /* Text & Icons */
    ".bold-text { font-weight: bold; font-size: 16px; }"
    ".scanner-icon { background: #EBF8FF; color: #3182CE; border-radius: 10px; padding: 8px; }"
    ".history-icon { background: #EDF2F7; color: #718096; border-radius: 50%; padding: 5px; }"
    "label { color: inherit; }";

static const char *CSS_DARK =
    "window { background-color: #171923; color: #F7FAFC; }"
    ".sidebar { background-color: #1A202C; border-right: 1px solid #2D3748; transition: min-width 200ms ease; }"
    ".dashboard-card-bg { background-color: #2D3748; border: 1px solid #4A5568; border-radius: 12px; }"
    ".protection-card-bg { background-color: #2D3748; border-radius: 12px; }"
    ".nav-item { background: transparent; border: none; border-radius: 6px; padding: 10px 12px; color: #A0AEC0; }"
    ".nav-item:hover { background: #2D3748; color: #FFFFFF; }"
    ".burger-btn { background: transparent; border: none; color: #A0AEC0; border-radius: 4px; padding: 8px; }"
    ".burger-btn:hover { background: #4A5568; color: #FFFFFF; }"
    ".scan-btn { background: #3182CE; color: white; border-radius: 8px; padding: 6px 16px; border: none; }"
    ".scan-btn:hover { background: #2B6CB0; }"
    ".flat-button { background: transparent; border: none; color: #E2E8F0; border-radius: 4px; padding: 4px; }"
    ".flat-button:hover { background: #4A5568; color: #FFFFFF; }"
    ".bold-text { font-weight: bold; font-size: 16px; }"
    ".scanner-icon { background: #2A4365; color: #63B3ED; border-radius: 10px; padding: 8px; }"
    ".history-icon { background: #2D3748; color: #A0AEC0; border-radius: 50%; padding: 5px; }"
    "label { color: inherit; }";

// --- Global Context ---
ScanContext global_scan_ctx;

// --- App State ---
typedef struct {
    GtkWidget *window;
    GtkWidget *sidebar;
    GtkWidget *stack;       
    GtkWidget *progress_bar;
    GtkWidget *progress_label;
    GtkWidget *result_files_label;
    GtkWidget *result_threats_label;
    GtkWidget *history_list_box; 

    GtkCssProvider *css_provider;
    gboolean is_dark_mode;
    gboolean is_sidebar_collapsed; 
    
    GList *sidebar_labels; 
} AppState;

extern int restore_file_from_quarantine(const char *q_path, const char *dest_path);

// --- Forward Declarations ---
GtkWidget *create_dashboard_view(AppState *app);
GtkWidget *create_scanner_progress_view(AppState *app);
GtkWidget *create_scan_complete_view(AppState *app);
GtkWidget *create_advanced_scan_view(AppState *app);
GtkWidget *create_history_view(AppState *app);
GtkWidget *create_settings_view(AppState *app);
static GtkWidget *last_update_label = NULL;


static void go_to_dashboard(GtkButton *btn, gpointer user_data);
static void go_to_advanced(GtkButton *btn, gpointer user_data);
static void go_to_history(GtkButton *btn, gpointer user_data);
static void go_to_settings(GtkButton *btn, gpointer user_data);
static void start_quick_scan(GtkButton *btn, gpointer user_data);
static void update_theme(AppState *app);
static void load_settings(void);
static void save_settings(void);

static gboolean auto_update_timer(gpointer user_data);
static gpointer silent_update_thread(gpointer data);
static gboolean needs_update_today(void);
static gpointer update_then_scan_thread(gpointer data);
static gboolean start_scan_from_idle(gpointer data);


typedef struct {
    AppState *app;
    char *scan_arg;
} ScanAfterUpdateCtx;

static void load_settings(void) {
    FILE *f = fopen(SETTINGS_FILE, "r");
    if (!f) return;

    char line[128];
    while (fgets(line, sizeof(line), f)) {
        if (strncmp(line, "auto_update=", 12) == 0) {
            auto_update_enabled = atoi(line + 12);
        } else if (strncmp(line, "last_update=", 12) == 0) {
            strncpy(last_update_time, line + 12, sizeof(last_update_time) - 1);
            last_update_time[strcspn(last_update_time, "\r\n")] = 0;
        }
    }
    fclose(f);
}

static void save_settings(void) {
    FILE *f = fopen(SETTINGS_FILE, "w");
    if (!f) return;

    fprintf(f, "auto_update=%d\n", auto_update_enabled ? 1 : 0);
    fprintf(f, "last_update=%s\n", last_update_time);
    fclose(f);
}

// --- Backend Logic ---
gpointer scan_worker_thread(gpointer user_data) {
    char *mode = (char *)user_data; 
    const char *db_path = "signatures.db"; 

    g_mutex_lock(&global_scan_ctx.mutex);
    global_scan_ctx.is_running = true;
    global_scan_ctx.stop_requested = false;
    global_scan_ctx.files_scanned = 0;
    global_scan_ctx.threats_found = 0;
    memset(global_scan_ctx.current_file, 0, 256);
    memset(global_scan_ctx.last_threat, 0, 256);
    g_mutex_unlock(&global_scan_ctx.mutex);

    if (strcmp(mode, "QUICK_SCAN") == 0) {
        // FETCH: Get the list of all critical paths from scan_core
        GList *paths = get_quick_scan_paths();
        GList *iter = paths;

        while (iter != NULL) {
            char *folder_path = (char *)iter->data;
            
            // Check for stop request before starting next folder
            g_mutex_lock(&global_scan_ctx.mutex);
            if (global_scan_ctx.stop_requested) { 
                g_mutex_unlock(&global_scan_ctx.mutex); 
                break; 
            }
            g_mutex_unlock(&global_scan_ctx.mutex);

            // Run scan on this specific folder
            signature_scan(db_path, folder_path);

            iter = iter->next;
        }

        // Cleanup the list
        g_list_free_full(paths, g_free);

    } else if (strcmp(mode, "FULL_SYSTEM") == 0) {
        signature_scan(db_path, "C:\\Users"); 
    } else {
        signature_scan(db_path, mode);
    }

    g_mutex_lock(&global_scan_ctx.mutex);
    global_scan_ctx.is_running = false;
    g_mutex_unlock(&global_scan_ctx.mutex);
    g_free(mode); 
    return NULL;
}

static gboolean on_scan_progress_tick(gpointer user_data) {
    AppState *app = (AppState *)user_data;
    g_mutex_lock(&global_scan_ctx.mutex);
    
    // Copy to local buffer to minimize mutex hold time
    char raw_file[256];
    strncpy(raw_file, global_scan_ctx.current_file, 255);
    raw_file[255] = '\0';

    bool still_running = global_scan_ctx.is_running;
    int final_files = global_scan_ctx.files_scanned;
    int final_threats = global_scan_ctx.threats_found;
    g_mutex_unlock(&global_scan_ctx.mutex);

    // FIX: Convert Windows ANSI path to UTF-8 for GTK
    GError *conv_err = NULL;
    char *utf8_file = g_locale_to_utf8(raw_file, -1, NULL, NULL, &conv_err);
    
    char file_label[512];
    if (utf8_file) {
        size_t len = strlen(utf8_file);
        // Smart truncation for long paths
        if (len > 40) 
            snprintf(file_label, sizeof(file_label), "Scanning: ...%s", &utf8_file[len - 40]);
        else 
            snprintf(file_label, sizeof(file_label), "Scanning: %s", utf8_file);
        g_free(utf8_file);
    } else {
        // Fallback if conversion fails (e.g. invalid chars)
        snprintf(file_label, sizeof(file_label), "Scanning: [System File]");
        if (conv_err) g_error_free(conv_err);
    }
    
    gtk_label_set_text(GTK_LABEL(app->progress_label), file_label);
    gtk_progress_bar_pulse(GTK_PROGRESS_BAR(app->progress_bar));

    if (!still_running) {
        gchar *f_txt = g_strdup_printf("Files Scanned: %d", final_files);
        gchar *t_txt = g_strdup_printf("Threats Found: %d", final_threats);
        gtk_label_set_text(GTK_LABEL(app->result_files_label), f_txt);
        gtk_label_set_text(GTK_LABEL(app->result_threats_label), t_txt);
        g_free(f_txt); g_free(t_txt);
        gtk_stack_set_visible_child_name(GTK_STACK(app->stack), "complete");
        return FALSE; 
    }
    return TRUE; 
}

static void start_scan_logic(AppState *app, char *path_or_mode) {

    gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(app->progress_bar), 0.0);
    gtk_stack_set_visible_child_name(GTK_STACK(app->stack), "progress");

    if (auto_update_enabled && needs_update_today()) {
        gtk_label_set_text(GTK_LABEL(app->progress_label), "Checking for updates...");

        ScanAfterUpdateCtx *ctx = g_new0(ScanAfterUpdateCtx, 1);
        ctx->app = app;
        ctx->scan_arg = path_or_mode;

        g_thread_new("UpdateThenScan", update_then_scan_thread, ctx);
    } else {
        gtk_label_set_text(GTK_LABEL(app->progress_label), "Initializing...");
        g_thread_new("Scanner", scan_worker_thread, path_or_mode);
    }

    g_timeout_add(100, on_scan_progress_tick, app);

}

static void start_quick_scan(GtkButton *btn, gpointer user_data) {
    start_scan_logic((AppState *)user_data, g_strdup("QUICK_SCAN"));
}

// --- MODERN FILE CHOOSER (Replacements for Deprecated Warnings) ---

static void on_folder_selected(GObject *source_object, GAsyncResult *res, gpointer user_data) {
    GtkFileDialog *dialog = GTK_FILE_DIALOG(source_object);
    AppState *app = (AppState *)user_data;
    GError *error = NULL;

    GFile *folder = gtk_file_dialog_select_folder_finish(dialog, res, &error);

    if (folder != NULL) {
        char *path = g_file_get_path(folder);
        if (path) {
            // FIX: DO NOT free 'path' here! 
            // We pass ownership to start_scan_logic -> scan_worker_thread.
            // The worker thread will g_free() it when finished.
            start_scan_logic(app, path); 
        }
        g_object_unref(folder);
    } else {
        if (error) g_error_free(error);
    }
}

static void on_browse_clicked(GtkButton *btn, gpointer user_data) {
    AppState *app = (AppState *)user_data;
    GtkFileDialog *dialog = gtk_file_dialog_new();
    gtk_file_dialog_set_title(dialog, "Select Folder to Scan");
    gtk_file_dialog_select_folder(dialog, GTK_WINDOW(app->window), NULL, on_folder_selected, app);
    g_object_unref(dialog);
}

static void update_theme(AppState *app) {
    if (app->is_dark_mode) gtk_css_provider_load_from_string(app->css_provider, CSS_DARK);
    else gtk_css_provider_load_from_string(app->css_provider, CSS_LIGHT);
}

static void on_dark_mode_toggled(GtkSwitch *widget, gboolean state, gpointer user_data) {
    AppState *app = (AppState *)user_data;
    app->is_dark_mode = state;
    update_theme(app);
}

typedef struct { char *orig_path; char *q_path; GtkWidget *row_widget; AppState *app; } RestoreData;

// --- Navigation ---
static void set_active_view(AppState *app, const char *view_name) {
    gtk_stack_set_visible_child_name(GTK_STACK(app->stack), view_name);
}
static void go_to_dashboard(GtkButton *btn, gpointer user_data) { set_active_view((AppState *)user_data, "dashboard"); }
static void go_to_advanced(GtkButton *btn, gpointer user_data) { set_active_view((AppState *)user_data, "advanced_scan"); }
static void go_to_history(GtkButton *btn, gpointer user_data) { set_active_view((AppState *)user_data, "history"); }
static void go_to_settings(GtkButton *btn, gpointer user_data) { set_active_view((AppState *)user_data, "settings"); }

// --- SIDEBAR LOGIC (Toggle functionality) ---

static void toggle_sidebar_collapse(GtkButton *btn, gpointer user_data) {
    AppState *app = (AppState *)user_data;
    app->is_sidebar_collapsed = !app->is_sidebar_collapsed;

    // 1. Hide/Show Labels
    GList *iter = app->sidebar_labels;
    while (iter != NULL) {
        GtkWidget *label = GTK_WIDGET(iter->data);
        gtk_widget_set_visible(label, !app->is_sidebar_collapsed);
        iter = iter->next;
    }

    // 2. Change width request aggressively
    if (app->is_sidebar_collapsed) {
        // Collapsed: 60px (Icon 16 + Padding 12 + 12 + Margins)
        gtk_widget_set_size_request(app->sidebar, 60, -1);
    } else {
        // Expanded: 200px
        gtk_widget_set_size_request(app->sidebar, 200, -1);
    }
}

GtkWidget *create_nav_item(AppState *app, const char *icon_name, const char *label_text) {
    GtkWidget *btn = gtk_button_new();
    gtk_widget_set_hexpand(btn, TRUE); // Ensure button fills width
    gtk_widget_add_css_class(btn, "nav-item");
    
    GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 12);
    // Align content to start, but icon remains visible when shrunk
    gtk_widget_set_halign(box, GTK_ALIGN_START); 
    
    GtkWidget *icon = gtk_image_new_from_icon_name(icon_name);
    // Important: Don't let icon shrink to 0
    gtk_widget_set_size_request(icon, 16, 16); 
    gtk_box_append(GTK_BOX(box), icon);

    GtkWidget *label = gtk_label_new(label_text);
    gtk_box_append(GTK_BOX(box), label);

    // Track label for collapsing
    app->sidebar_labels = g_list_append(app->sidebar_labels, label);

    gtk_button_set_child(GTK_BUTTON(btn), box);
    return btn;
}

GtkWidget *create_sidebar(AppState *app) {
    GtkWidget *sidebar = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0); 
    app->sidebar = sidebar; 
    
    // Initial Width: 200px
    gtk_widget_set_size_request(sidebar, 200, -1); 
    gtk_widget_set_hexpand(sidebar, FALSE); // CRITICAL: Don't let it auto-expand
    gtk_widget_add_css_class(sidebar, "sidebar");

    // --- BURGER BUTTON (Top Left) ---
    GtkWidget *header_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    gtk_widget_set_margin_top(header_box, 15);
    // Align margin with the Nav Items (12px padding inside button + 10px margin = ~22px indent)
    gtk_widget_set_margin_start(header_box, 15); 
    gtk_widget_set_margin_bottom(header_box, 20);

    GtkWidget *burger_btn = gtk_button_new();
    gtk_widget_add_css_class(burger_btn, "burger-btn");
    GtkWidget *burger_icon = gtk_image_new_from_icon_name("open-menu-symbolic");
    gtk_button_set_child(GTK_BUTTON(burger_btn), burger_icon);
    
    g_signal_connect(burger_btn, "clicked", G_CALLBACK(toggle_sidebar_collapse), app);
    gtk_box_append(GTK_BOX(header_box), burger_btn);

    gtk_box_append(GTK_BOX(sidebar), header_box);
    
    // --- Navigation Items ---
    GtkWidget *nav_group = gtk_box_new(GTK_ORIENTATION_VERTICAL, 4);
    gtk_widget_set_margin_start(nav_group, 10);
    gtk_widget_set_margin_end(nav_group, 10);

    GtkWidget *dash_btn = create_nav_item(app, "view-grid-symbolic", "Dashboard"); 
    g_signal_connect(dash_btn, "clicked", G_CALLBACK(go_to_dashboard), app);
    gtk_box_append(GTK_BOX(nav_group), dash_btn);

    GtkWidget *hist_btn = create_nav_item(app, "document-open-recent-symbolic", "History");
    g_signal_connect(hist_btn, "clicked", G_CALLBACK(go_to_history), app);
    gtk_box_append(GTK_BOX(nav_group), hist_btn);

    gtk_box_append(GTK_BOX(sidebar), nav_group);

    // Spacer
    GtkWidget *spacer = gtk_label_new(""); 
    gtk_widget_set_vexpand(spacer, TRUE);
    gtk_box_append(GTK_BOX(sidebar), spacer);

    // Settings at Bottom
    GtkWidget *sett_group = gtk_box_new(GTK_ORIENTATION_VERTICAL, 4);
    gtk_widget_set_margin_start(sett_group, 10);
    gtk_widget_set_margin_end(sett_group, 10);
    gtk_widget_set_margin_bottom(sett_group, 20);

    GtkWidget *sett_btn = create_nav_item(app, "preferences-system-symbolic", "Settings");
    
    // FIX: Use 'go_to_settings' which you already defined at line 268.
    // Do NOT use 'on_nav_clicked' because it does not exist in your file.
    g_signal_connect(sett_btn, "clicked", G_CALLBACK(go_to_settings), app);
    
    gtk_box_append(GTK_BOX(sett_group), sett_btn);

    gtk_box_append(GTK_BOX(sidebar), sett_group);

    return sidebar;
}

GtkWidget *create_topbar(AppState *app) {
    GtkWidget *topbar = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 15);
    gtk_widget_set_margin_top(topbar, 10);
    gtk_widget_set_margin_start(topbar, 15); gtk_widget_set_margin_end(topbar, 15);

    // Sidebar toggle is now inside Sidebar, so we just have logo here
    GtkWidget *logo = gtk_label_new(NULL);
    gtk_label_set_markup(GTK_LABEL(logo), "<span font='22px' weight='bold' foreground='#3182CE'>üõ°Ô∏èFOS-ANTIVIRUS</span>");
    gtk_box_append(GTK_BOX(topbar), logo);

    return topbar;
}

// --- Views ---

GtkWidget *create_dashboard_view(AppState *app) {
    GtkWidget *col = gtk_box_new(GTK_ORIENTATION_VERTICAL, 20);
    gtk_widget_set_margin_start(col, 30); gtk_widget_set_margin_top(col, 30);
    gtk_widget_set_margin_end(col, 30);
    
    GtkWidget *title = gtk_label_new(NULL);
    gtk_label_set_markup(GTK_LABEL(title), "<span font='28px' weight='bold'>Overview</span>");
    gtk_widget_set_halign(title, GTK_ALIGN_START);
    gtk_box_append(GTK_BOX(col), title);

    // Scanner Card
    GtkWidget *card = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 20);
    gtk_widget_add_css_class(card, "dashboard-card-bg");
    gtk_widget_set_size_request(card, -1, 100);
    
    GtkWidget *icon = gtk_image_new_from_icon_name("media-record-symbolic");
    gtk_widget_set_size_request(icon, 40, 40); gtk_widget_set_valign(icon, GTK_ALIGN_CENTER); gtk_widget_set_margin_start(icon, 20);
    gtk_widget_add_css_class(icon, "scanner-icon");
    gtk_box_append(GTK_BOX(card), icon);
    
    GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);
    gtk_widget_set_valign(vbox, GTK_ALIGN_CENTER);
    GtkWidget *l1 = gtk_label_new("Quick Scan"); gtk_widget_set_halign(l1, GTK_ALIGN_START); gtk_widget_add_css_class(l1, "bold-text");
    GtkWidget *l2 = gtk_label_new("Scans critical system areas"); gtk_widget_set_halign(l2, GTK_ALIGN_START);
    gtk_box_append(GTK_BOX(vbox), l1); gtk_box_append(GTK_BOX(vbox), l2);
    gtk_box_append(GTK_BOX(card), vbox);
    
    GtkWidget *spacer = gtk_label_new(""); gtk_widget_set_hexpand(spacer, TRUE); gtk_box_append(GTK_BOX(card), spacer);

    GtkWidget *scan_btn = gtk_button_new_with_label("Start Scan");
    gtk_widget_add_css_class(scan_btn, "scan-btn"); gtk_widget_set_margin_end(scan_btn, 20); gtk_widget_set_valign(scan_btn, GTK_ALIGN_CENTER);
    g_signal_connect(scan_btn, "clicked", G_CALLBACK(start_quick_scan), app);
    gtk_box_append(GTK_BOX(card), scan_btn);
    
    GtkWidget *adv_btn = gtk_button_new();
    gtk_widget_add_css_class(adv_btn, "flat-button");
    gtk_button_set_child(GTK_BUTTON(adv_btn), gtk_image_new_from_icon_name("view-more-horizontal-symbolic"));
    g_signal_connect(adv_btn, "clicked", G_CALLBACK(go_to_advanced), app);
    gtk_box_append(GTK_BOX(card), adv_btn);

    gtk_box_append(GTK_BOX(col), card);
    return col;
}

GtkWidget *create_advanced_scan_view(AppState *app) {
    GtkWidget *view = gtk_box_new(GTK_ORIENTATION_VERTICAL, 20);
    gtk_widget_set_margin_start(view, 30); gtk_widget_set_margin_top(view, 30); gtk_widget_set_margin_end(view, 30);
    gtk_box_append(GTK_BOX(view), gtk_label_new("Advanced Scan"));
    GtkWidget *custom_card = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 20);
    gtk_widget_add_css_class(custom_card, "dashboard-card-bg");
    gtk_widget_set_size_request(custom_card, -1, 80);
    gtk_box_append(GTK_BOX(custom_card), gtk_label_new("  Custom Scan (Select Directory)"));
    GtkWidget *sp1 = gtk_label_new(""); gtk_widget_set_hexpand(sp1, TRUE); gtk_box_append(GTK_BOX(custom_card), sp1);
    GtkWidget *sel_btn = gtk_button_new_with_label("Browse Files...");
    gtk_widget_add_css_class(sel_btn, "scan-btn"); gtk_widget_set_margin_end(sel_btn, 20);
    g_signal_connect(sel_btn, "clicked", G_CALLBACK(on_browse_clicked), app);
    gtk_box_append(GTK_BOX(custom_card), sel_btn);
    gtk_box_append(GTK_BOX(view), custom_card);
    GtkWidget *back_btn = gtk_button_new_with_label("Back");
    gtk_widget_set_halign(back_btn, GTK_ALIGN_START);
    gtk_widget_add_css_class(back_btn, "flat-button");
    g_signal_connect(back_btn, "clicked", G_CALLBACK(go_to_dashboard), app);
    gtk_box_append(GTK_BOX(view), back_btn);
    return view;
}

// --- UPDATE UI LOGIC START ---

static GtkWidget *update_dialog = NULL;
static GtkWidget *update_progress_bar = NULL;
static GtkWidget *update_status_label = NULL;

// 1. Timer that updates the UI every 100ms
static gboolean check_update_progress(gpointer user_data) {
    if (!update_dialog) return G_SOURCE_REMOVE;

    // Convert 0-100 int to 0.0-1.0 double
    double fraction = (double)update_progress / 100.0;
    if (fraction > 1.0) fraction = 1.0;
    if (fraction < 0) fraction = 0;

    gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(update_progress_bar), fraction);
    
    char buf[64];
    if (update_progress < 100 && update_progress >= 0) {
        snprintf(buf, 64, "Downloading Database... %d%%", update_progress);
        gtk_label_set_text(GTK_LABEL(update_status_label), buf);
    }

    // Completion Check
    if (update_progress == 101) {
        gtk_label_set_text(GTK_LABEL(update_status_label), "Update Complete!");
        gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(update_progress_bar), 1.0);
        
        // Auto-close after 1.5 seconds
        g_timeout_add(1500, (GSourceFunc)gtk_window_destroy, update_dialog);
        update_dialog = NULL;
        return G_SOURCE_REMOVE;
    } 
    // Error Check
    else if (update_progress == -1) {
        gtk_label_set_text(GTK_LABEL(update_status_label), "Error: Update Failed. Check Internet.");
        // We leave the dialog open so the user sees the error
        return G_SOURCE_REMOVE;
    }

    return G_SOURCE_CONTINUE;
}

// 2. The Button Click Handler
static void on_update_clicked(GtkButton *btn, gpointer user_data) {
    AppState *app = (AppState *)user_data;
    
    // Safety check
    g_mutex_lock(&global_scan_ctx.mutex);
    if (global_scan_ctx.is_running) {
        g_mutex_unlock(&global_scan_ctx.mutex);
        GtkAlertDialog *alert = gtk_alert_dialog_new("Cannot update while scanning.");
        gtk_alert_dialog_show(alert, GTK_WINDOW(app->window));
        return;
    }
    g_mutex_unlock(&global_scan_ctx.mutex);

    // Create the Pop-up Window
    update_dialog = gtk_window_new();
    gtk_window_set_title(GTK_WINDOW(update_dialog), "Database Update");
    gtk_window_set_modal(GTK_WINDOW(update_dialog), TRUE);
    gtk_window_set_transient_for(GTK_WINDOW(update_dialog), GTK_WINDOW(app->window));
    gtk_window_set_default_size(GTK_WINDOW(update_dialog), 350, 120);
    
    // Layout
    GtkWidget *box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 15);
    gtk_widget_set_margin_top(box, 25);
    gtk_widget_set_margin_bottom(box, 25);
    gtk_widget_set_margin_start(box, 25);
    gtk_widget_set_margin_end(box, 25);
    gtk_window_set_child(GTK_WINDOW(update_dialog), box);

    // Label
    update_status_label = gtk_label_new("Initializing connection...");
    gtk_box_append(GTK_BOX(box), update_status_label);

    // Progress Bar
    update_progress_bar = gtk_progress_bar_new();
    gtk_widget_set_size_request(update_progress_bar, 250, 25);
    gtk_progress_bar_set_show_text(GTK_PROGRESS_BAR(update_progress_bar), TRUE);
    gtk_box_append(GTK_BOX(box), update_progress_bar);

    gtk_window_present(GTK_WINDOW(update_dialog));

    // Start background thread
    update_progress = 0;
    g_thread_new("Updater", (GThreadFunc)update_signature_db, "signatures.db");

    // Start UI Timer to watch progress
    g_timeout_add(100, check_update_progress, NULL);
}

static gboolean on_auto_update_toggled(GtkSwitch *widget, gboolean state, gpointer user_data) {
    auto_update_enabled = state;
    save_settings();
    return FALSE; // allow GTK to update switch state
}

static gboolean needs_update_today(void) {
    if (strcmp(last_update_time, "Never") == 0)
        return TRUE;

    char today[16];
    time_t now = time(NULL);
    struct tm *tm_info = localtime(&now);
    strftime(today, sizeof(today), "%Y-%m-%d", tm_info);

    return strncmp(last_update_time, today, 10) != 0;
}

static gboolean refresh_last_update_label(gpointer data) {
    if (!last_update_label)
        return G_SOURCE_REMOVE;

    char buf[128];
    snprintf(buf, sizeof(buf), "Last updated: %s", last_update_time);
    gtk_label_set_text(GTK_LABEL(last_update_label), buf);

    return G_SOURCE_REMOVE;
}


// --- UPDATE UI LOGIC END ---
GtkWidget *create_settings_view(AppState *app) {
    GtkWidget *view = gtk_box_new(GTK_ORIENTATION_VERTICAL, 20);
    gtk_widget_set_margin_start(view, 30); gtk_widget_set_margin_top(view, 30); gtk_widget_set_margin_end(view, 30);
    GtkWidget *title = gtk_label_new(NULL);
    gtk_label_set_markup(GTK_LABEL(title), "<span font='28px' weight='bold'>Settings</span>");
    gtk_widget_set_halign(title, GTK_ALIGN_START);
    gtk_box_append(GTK_BOX(view), title);
    GtkWidget *card = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 20);
    gtk_widget_add_css_class(card, "dashboard-card-bg");
    gtk_widget_set_size_request(card, -1, 80);
    GtkWidget *lbl = gtk_label_new("  Dark Mode");
    gtk_widget_add_css_class(lbl, "bold-text");
    gtk_box_append(GTK_BOX(card), lbl);
    GtkWidget *spacer = gtk_label_new(""); gtk_widget_set_hexpand(spacer, TRUE);
    gtk_box_append(GTK_BOX(card), spacer);
    GtkSwitch *sw = GTK_SWITCH(gtk_switch_new());
    gtk_switch_set_active(sw, app->is_dark_mode);
    g_signal_connect(sw, "state-set", G_CALLBACK(on_dark_mode_toggled), app);
    gtk_widget_set_margin_end(GTK_WIDGET(sw), 20);
    gtk_widget_set_valign(GTK_WIDGET(sw), GTK_ALIGN_CENTER);
    gtk_box_append(GTK_BOX(card), GTK_WIDGET(sw));
    gtk_box_append(GTK_BOX(view), card);

    // --- Threat Signature Update Card ---
    GtkWidget *update_card = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 20);
    gtk_widget_add_css_class(update_card, "dashboard-card-bg");
    gtk_widget_set_size_request(update_card, -1, 80);

    // Title (left)
    GtkWidget *upd_lbl = gtk_label_new("Threat Signature Database");
    gtk_widget_add_css_class(upd_lbl, "bold-text");
    gtk_widget_set_halign(upd_lbl, GTK_ALIGN_START);
    gtk_widget_set_valign(upd_lbl, GTK_ALIGN_CENTER);
    gtk_widget_set_margin_start(upd_lbl, 20);
    gtk_box_append(GTK_BOX(update_card), upd_lbl);

    // Spacer (pushes toggle to right)
    GtkWidget *update_spacer = gtk_label_new("");
    gtk_widget_set_hexpand(update_spacer, TRUE);
    gtk_box_append(GTK_BOX(update_card), update_spacer);

    // Right side container
    GtkWidget *right_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 4);
    gtk_widget_set_margin_end(right_box, 20);
    gtk_widget_set_halign(right_box, GTK_ALIGN_END);
    gtk_widget_set_valign(right_box, GTK_ALIGN_CENTER);

    // --- Switch wrapper (CRITICAL for size parity) ---
    GtkWidget *switch_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    gtk_widget_set_halign(switch_box, GTK_ALIGN_END);
    gtk_widget_set_valign(switch_box, GTK_ALIGN_CENTER);

    // Auto-update switch (forced compact size)
    GtkSwitch *auto_sw = GTK_SWITCH(gtk_switch_new());
    gtk_switch_set_active(auto_sw, auto_update_enabled);
    gtk_widget_set_hexpand(GTK_WIDGET(auto_sw), FALSE);
    gtk_widget_set_vexpand(GTK_WIDGET(auto_sw), FALSE);
    gtk_widget_set_halign(GTK_WIDGET(auto_sw), GTK_ALIGN_END);
    gtk_widget_set_valign(GTK_WIDGET(auto_sw), GTK_ALIGN_CENTER);

    g_signal_connect(auto_sw, "state-set",
                    G_CALLBACK(on_auto_update_toggled), app);

    // Put switch inside horizontal wrapper
    gtk_box_append(GTK_BOX(switch_box), GTK_WIDGET(auto_sw));
    gtk_box_append(GTK_BOX(right_box), switch_box);

    // Last updated label (below switch)
    char lbl_buf[128];
    snprintf(lbl_buf, sizeof(lbl_buf), "Last updated: %s", last_update_time);

    GtkWidget *last_lbl = gtk_label_new(lbl_buf);
    last_update_label = last_lbl;
    gtk_widget_set_halign(last_lbl, GTK_ALIGN_END);
    gtk_widget_add_css_class(last_lbl, "dim-label");

    gtk_box_append(GTK_BOX(right_box), last_lbl);

    // Assemble card
    gtk_box_append(GTK_BOX(update_card), right_box);
    gtk_box_append(GTK_BOX(view), update_card);

    return view;
}

static gpointer silent_update_thread(gpointer data) {
    int result = update_signature_db("signatures.db");
    if (result == 0) {
        time_t now = time(NULL);
        struct tm *tm_info = localtime(&now);
        strftime(last_update_time, sizeof(last_update_time),
                "%Y-%m-%d %H:%M", tm_info);
        save_settings();

        // Update UI safely
        g_idle_add((GSourceFunc)refresh_last_update_label, NULL);
    }


    return NULL;
}

static gboolean auto_update_timer(gpointer user_data) {
    if (!auto_update_enabled)
        return G_SOURCE_CONTINUE;

    if (strcmp(last_update_time, "Never") != 0) {
        char today[16];
        time_t now = time(NULL);
        struct tm *tm_info = localtime(&now);
        strftime(today, sizeof(today), "%Y-%m-%d", tm_info);

        if (strncmp(last_update_time, today, 10) == 0) {
            return G_SOURCE_CONTINUE; // already updated today
        }
    }

    // Do NOT update while scanning
    g_mutex_lock(&global_scan_ctx.mutex);
    if (global_scan_ctx.is_running) {
        g_mutex_unlock(&global_scan_ctx.mutex);
        return G_SOURCE_CONTINUE;
    }
    g_mutex_unlock(&global_scan_ctx.mutex);

    g_thread_new("SilentUpdater", silent_update_thread, NULL);
    return G_SOURCE_CONTINUE;
}

static gboolean start_scan_from_idle(gpointer data) {
    ScanAfterUpdateCtx *ctx = data;
    gtk_label_set_text(GTK_LABEL(ctx->app->progress_label), "Initializing...");
    g_thread_new("Scanner", scan_worker_thread, ctx->scan_arg);
    g_free(ctx);
    return G_SOURCE_REMOVE;
}

static gpointer update_then_scan_thread(gpointer data) {
    ScanAfterUpdateCtx *ctx = data;

    int res = update_signature_db("signatures.db");
    if (res == 0) {
        time_t now = time(NULL);
        struct tm *tm_info = localtime(&now);
        strftime(last_update_time, sizeof(last_update_time),
                 "%Y-%m-%d %H:%M", tm_info);
        save_settings();

        // Update label safely
        g_idle_add((GSourceFunc)refresh_last_update_label, NULL);
    }

    // Hand control back to GTK main loop
    g_idle_add(start_scan_from_idle, ctx);

    return NULL;
}

// 1. Updated Data Structure to hold button references
typedef struct {
    char *orig_path;
    char *q_path;
    GtkWidget *lbl_status;  // To change text to "Restored" or "Removed"
    GtkWidget *btn_restore; // To disable button
    GtkWidget *btn_remove;  // To disable button
    AppState *app;
} HistoryActionData;

static void free_history_action_data(gpointer data) {
    HistoryActionData *d = (HistoryActionData *)data;
    if (d->orig_path) g_free(d->orig_path);
    if (d->q_path) g_free(d->q_path);
    g_free(d);
}

// 2. Updated Remove Callback (Adds Popup + Disables Buttons)
static void on_remove_clicked(GtkButton *btn, gpointer user_data) {
    HistoryActionData *data = (HistoryActionData *)user_data;
    
    // Perform Delete
    remove(data->q_path); 

    // Update UI: Change Status & Disable Buttons
    gtk_label_set_text(GTK_LABEL(data->lbl_status), "Removed");
    gtk_widget_set_sensitive(data->btn_restore, FALSE);
    gtk_widget_set_sensitive(data->btn_remove, FALSE);

    // Show Success Alert (New Request)
    GtkAlertDialog *alert = gtk_alert_dialog_new("File Permanently Removed");
    gtk_alert_dialog_show(alert, GTK_WINDOW(data->app->window));
    g_object_unref(alert);
}

// 3. Updated Restore Callback (Disables Buttons on Success)
static void on_restore_clicked(GtkButton *btn, gpointer user_data) {
    HistoryActionData *data = (HistoryActionData *)user_data;
    
    if (restore_file_from_quarantine(data->q_path, data->orig_path) == 0) {
        // Success: Update UI
        gtk_label_set_text(GTK_LABEL(data->lbl_status), "Restored");
        gtk_widget_set_sensitive(data->btn_restore, FALSE);
        gtk_widget_set_sensitive(data->btn_remove, FALSE);
        
        GtkAlertDialog *alert = gtk_alert_dialog_new("File Restored Successfully");
        gtk_alert_dialog_show(alert, GTK_WINDOW(data->app->window));
        g_object_unref(alert);
    } else {
        GtkAlertDialog *alert = gtk_alert_dialog_new("Failed to Restore. Check permissions.");
        gtk_alert_dialog_show(alert, GTK_WINDOW(data->app->window));
        g_object_unref(alert);
    }
}

// 4. Updated Load Function (Connects the buttons to the struct)
static void load_history_items(AppState *app) {
    // STEP 0: Clear existing children to prevent duplicates
    GtkWidget *child = gtk_widget_get_first_child(app->history_list_box);
    while (child != NULL) {
        GtkWidget *next = gtk_widget_get_next_sibling(child);
        gtk_list_box_remove(GTK_LIST_BOX(app->history_list_box), child);
        child = next;
    }

    FILE *f = fopen("history.log", "r");
    if (!f) return;

    // STEP 1: Track latest occurrence of each original file path
    GHashTable *latest_entry =
        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);

    char line[1024];

    /* ============================
       PASS 1: Identify latest entry
       ============================ */
    while (fgets(line, sizeof(line), f)) {
        line[strcspn(line, "\r\n")] = 0;

        char *copy = g_strdup(line);

        strtok(copy, "|");          // date
        strtok(NULL, "|");          // threat
        char *token_orig = strtok(NULL, "|");

        if (token_orig) {
            // Latest occurrence wins
            g_hash_table_replace(
                latest_entry,
                g_strdup(token_orig),
                GINT_TO_POINTER(1)
            );
        }

        g_free(copy);
    }

    rewind(f);

    /* ============================
       PASS 2: Build UI
       ============================ */
    while (fgets(line, sizeof(line), f)) {
        line[strcspn(line, "\r\n")] = 0;

        char *token_date   = strtok(line, "|");
        char *token_threat = strtok(NULL, "|");
        char *token_orig   = strtok(NULL, "|");
        char *token_qpath  = strtok(NULL, "|");

        if (!token_date || !token_orig || !token_qpath)
            continue;

        // Is this the latest entry for this file?
        bool is_latest =
            g_hash_table_contains(latest_entry, token_orig);

        // Does quarantine file exist?
        bool quarantine_exists =
            (GetFileAttributesA(token_qpath) != INVALID_FILE_ATTRIBUTES);

        // Extract filename
        char *filename = strrchr(token_orig, '\\');
        if (!filename) filename = strrchr(token_orig, '/');
        filename = (filename) ? filename + 1 : token_orig;

        /* ---------- UI ROW ---------- */
        GtkWidget *row = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 15);
        gtk_widget_set_margin_start(row, 10);
        gtk_widget_set_margin_end(row, 10);
        gtk_widget_set_margin_top(row, 8);
        gtk_widget_set_margin_bottom(row, 8);

        GtkWidget *lbl_name = gtk_label_new(filename);
        gtk_widget_set_size_request(lbl_name, 120, -1);
        gtk_widget_set_halign(lbl_name, GTK_ALIGN_START);
        gtk_label_set_ellipsize(GTK_LABEL(lbl_name), PANGO_ELLIPSIZE_END);
        gtk_box_append(GTK_BOX(row), lbl_name);

        GtkWidget *lbl_path = gtk_label_new(token_orig);
        gtk_widget_set_hexpand(lbl_path, TRUE);
        gtk_widget_set_halign(lbl_path, GTK_ALIGN_START);
        gtk_label_set_ellipsize(GTK_LABEL(lbl_path), PANGO_ELLIPSIZE_START);
        gtk_box_append(GTK_BOX(row), lbl_path);

        GtkWidget *lbl_date = gtk_label_new(token_date);
        gtk_widget_set_size_request(lbl_date, 140, -1);
        gtk_box_append(GTK_BOX(row), lbl_date);

        // Status
        GtkWidget *lbl_status;
        if (quarantine_exists && is_latest) {
            lbl_status = gtk_label_new("Quarantined");
        } else {
            lbl_status = gtk_label_new("Action Taken");
        }
        gtk_widget_set_size_request(lbl_status, 100, -1);
        gtk_box_append(GTK_BOX(row), lbl_status);

        // Actions
        GtkWidget *actions_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);

        GtkWidget *btn_restore =
            gtk_button_new_from_icon_name("system-reboot-symbolic");
        gtk_widget_set_tooltip_text(btn_restore, "Restore File");

        GtkWidget *btn_remove =
            gtk_button_new_from_icon_name("user-trash-symbolic");
        gtk_widget_set_tooltip_text(btn_remove, "Delete Permanently");

        // FINAL RULE: Only latest + existing quarantine is actionable
        if (!quarantine_exists || !is_latest) {
            gtk_widget_set_sensitive(btn_restore, FALSE);
            gtk_widget_set_sensitive(btn_remove, FALSE);
        }

        /* ---------- BIND DATA ---------- */
        HistoryActionData *data = g_new0(HistoryActionData, 1);
        data->orig_path   = g_strdup(token_orig);
        data->q_path      = g_strdup(token_qpath);
        data->lbl_status  = lbl_status;
        data->btn_restore = btn_restore;
        data->btn_remove  = btn_remove;
        data->app         = app;

        g_signal_connect_data(
            btn_restore, "clicked",
            G_CALLBACK(on_restore_clicked),
            data, NULL, 0
        );

        g_signal_connect_data(
            btn_remove, "clicked",
            G_CALLBACK(on_remove_clicked),
            data, NULL, 0
        );

        g_object_set_data_full(
            G_OBJECT(row),
            "action_data",
            data,
            free_history_action_data
        );

        gtk_box_append(GTK_BOX(actions_box), btn_restore);
        gtk_box_append(GTK_BOX(actions_box), btn_remove);
        gtk_box_append(GTK_BOX(row), actions_box);

        gtk_list_box_append(GTK_LIST_BOX(app->history_list_box), row);
    }

    fclose(f);
    g_hash_table_destroy(latest_entry);
}

GtkWidget *create_history_view(AppState *app) {
    GtkWidget *view = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);
    gtk_widget_set_margin_top(view, 30);
    gtk_widget_set_margin_start(view, 30);
    gtk_widget_set_margin_end(view, 30);

    // Title
    GtkWidget *title = gtk_label_new(NULL);
    gtk_label_set_markup(GTK_LABEL(title), "<span font='28px' weight='bold'>Detection History</span>");
    gtk_widget_set_halign(title, GTK_ALIGN_START);
    gtk_widget_set_margin_bottom(title, 20);
    gtk_box_append(GTK_BOX(view), title);

    // --- Table Headers ---
    GtkWidget *header_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 15);
    gtk_widget_set_margin_start(header_box, 10);
    gtk_widget_set_margin_end(header_box, 20); // Account for scrollbar space
    
    // Helper macro to add header labels matching the row widths
    #define ADD_HEADER(text, width, expand) \
        { GtkWidget *l = gtk_label_new(text); \
          gtk_widget_add_css_class(l, "bold-text"); \
          gtk_widget_set_halign(l, GTK_ALIGN_START); \
          if(width > 0) gtk_widget_set_size_request(l, width, -1); \
          if(expand) gtk_widget_set_hexpand(l, TRUE); \
          gtk_box_append(GTK_BOX(header_box), l); }

    ADD_HEADER("File Name", 120, FALSE);
    ADD_HEADER("Original Path", -1, TRUE);
    ADD_HEADER("Date/Time", 140, FALSE);
    ADD_HEADER("Status", 100, FALSE);
    ADD_HEADER("Action", -1, FALSE); // Action column

    gtk_box_append(GTK_BOX(view), header_box);
    gtk_box_append(GTK_BOX(view), gtk_separator_new(GTK_ORIENTATION_HORIZONTAL));

    // List Box container
    app->history_list_box = gtk_list_box_new();
    gtk_widget_add_css_class(app->history_list_box, "dashboard-card-bg");
    
    // Allow rows to be non-selectable (since we have buttons)
    gtk_list_box_set_selection_mode(GTK_LIST_BOX(app->history_list_box), GTK_SELECTION_NONE);

    // Scroll Window
    GtkWidget *scroll = gtk_scrolled_window_new();
    gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(scroll), app->history_list_box);
    gtk_widget_set_vexpand(scroll, TRUE);
    gtk_box_append(GTK_BOX(view), scroll);

    // Load Data
    load_history_items(app);

    return view;
}

static void cancel_scan(GtkButton *btn, gpointer user_data) {
    g_mutex_lock(&global_scan_ctx.mutex);
    global_scan_ctx.stop_requested = true;
    g_mutex_unlock(&global_scan_ctx.mutex);
}

GtkWidget *create_scanner_progress_view(AppState *app) {
    GtkWidget *view = gtk_box_new(GTK_ORIENTATION_VERTICAL, 20);
    gtk_widget_set_halign(view, GTK_ALIGN_CENTER); gtk_widget_set_valign(view, GTK_ALIGN_CENTER);
    GtkWidget *card = gtk_box_new(GTK_ORIENTATION_VERTICAL, 30);
    gtk_widget_add_css_class(card, "dashboard-card-bg");
    gtk_widget_set_size_request(card, 500, 250);
    gtk_box_append(GTK_BOX(card), gtk_label_new("Scan in Progress..."));
    app->progress_label = gtk_label_new("Initializing...");
    gtk_box_append(GTK_BOX(card), app->progress_label);
    app->progress_bar = gtk_progress_bar_new();
    gtk_widget_set_margin_start(app->progress_bar, 20); gtk_widget_set_margin_end(app->progress_bar, 20);
    gtk_box_append(GTK_BOX(card), app->progress_bar);
    GtkWidget *cancel_btn = gtk_button_new_with_label("Cancel Scan");
    g_signal_connect(cancel_btn, "clicked", G_CALLBACK(cancel_scan), app);
    gtk_box_append(GTK_BOX(card), cancel_btn);
    gtk_box_append(GTK_BOX(view), card);
    return view;
}

GtkWidget *create_scan_complete_view(AppState *app) {
    GtkWidget *view = gtk_box_new(GTK_ORIENTATION_VERTICAL, 20);
    gtk_widget_set_halign(view, GTK_ALIGN_CENTER); gtk_widget_set_valign(view, GTK_ALIGN_CENTER);
    GtkWidget *card = gtk_box_new(GTK_ORIENTATION_VERTICAL, 20);
    gtk_widget_add_css_class(card, "dashboard-card-bg");
    gtk_widget_set_size_request(card, 400, 250);
    GtkWidget *icon = gtk_image_new_from_icon_name("security-high-symbolic");
    gtk_widget_set_size_request(icon, 64, 64); gtk_widget_add_css_class(icon, "scanner-icon"); 
    gtk_box_append(GTK_BOX(card), icon);
    gtk_box_append(GTK_BOX(card), gtk_label_new("Scan Complete"));
    GtkWidget *grid = gtk_grid_new();
    gtk_widget_set_halign(grid, GTK_ALIGN_CENTER); gtk_grid_set_row_spacing(GTK_GRID(grid), 10); gtk_grid_set_column_spacing(GTK_GRID(grid), 20);
    gtk_box_append(GTK_BOX(card), grid);
    app->result_files_label = gtk_label_new("Files Scanned: 0");
    app->result_threats_label = gtk_label_new("Threats Found: 0");
    gtk_grid_attach(GTK_GRID(grid), app->result_files_label, 0, 0, 1, 1);
    gtk_grid_attach(GTK_GRID(grid), app->result_threats_label, 0, 1, 1, 1);
    GtkWidget *home_btn = gtk_button_new_with_label("Back to Dashboard");
    gtk_widget_add_css_class(home_btn, "scan-btn"); 
    g_signal_connect(home_btn, "clicked", G_CALLBACK(go_to_dashboard), app);
    gtk_box_append(GTK_BOX(card), home_btn);
    gtk_box_append(GTK_BOX(view), card);
    return view;
}

// Callback to reload history whenever the user switches to the 'History' tab
static void on_stack_changed(GtkStack *stack, GParamSpec *pspec, AppState *app) {
    const char *visible_child_name = gtk_stack_get_visible_child_name(stack);
    if (visible_child_name && strcmp(visible_child_name, "history") == 0) {
        // User just switched to History tab -> Reload
        load_history_items(app);
    }
}

static void activate(GtkApplication *gtk_app, gpointer user_data) {
    AppState *app = g_new0(AppState, 1); 
    app->window = gtk_application_window_new(gtk_app);
    gtk_window_set_default_size(GTK_WINDOW(app->window), 1000, 650);
    gtk_window_set_title(GTK_WINDOW(app->window), "FOS-Antivirus");

    GtkWidget *main_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    gtk_window_set_child(GTK_WINDOW(app->window), main_box);
    gtk_box_append(GTK_BOX(main_box), create_sidebar(app));

    GtkWidget *content = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    gtk_widget_set_hexpand(content, TRUE);
    gtk_box_append(GTK_BOX(main_box), content);
    gtk_box_append(GTK_BOX(content), create_topbar(app));

    GtkWidget *body_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 15);
    gtk_widget_set_vexpand(body_box, TRUE);
    gtk_box_append(GTK_BOX(content), body_box);

    app->stack = gtk_stack_new();
    gtk_stack_set_transition_type(GTK_STACK(app->stack), GTK_STACK_TRANSITION_TYPE_CROSSFADE);
    g_signal_connect(app->stack, "notify::visible-child", G_CALLBACK(on_stack_changed), app);
    
    gtk_stack_add_titled(GTK_STACK(app->stack), create_dashboard_view(app), "dashboard", "Dashboard");
    gtk_stack_add_titled(GTK_STACK(app->stack), create_advanced_scan_view(app), "advanced_scan", "Advanced");
    gtk_stack_add_titled(GTK_STACK(app->stack), create_history_view(app), "history", "History");
    gtk_stack_add_titled(GTK_STACK(app->stack), create_settings_view(app), "settings", "Settings");
    gtk_stack_add_titled(GTK_STACK(app->stack), create_scanner_progress_view(app), "progress", "Progress");
    gtk_stack_add_titled(GTK_STACK(app->stack), create_scan_complete_view(app), "complete", "Complete"); 
    
    gtk_box_append(GTK_BOX(body_box), app->stack);

    app->css_provider = gtk_css_provider_new();
    app->is_dark_mode = FALSE;
    update_theme(app);
    
    gtk_style_context_add_provider_for_display(gdk_display_get_default(), GTK_STYLE_PROVIDER(app->css_provider), GTK_STYLE_PROVIDER_PRIORITY_USER);

    load_settings();

    if (auto_update_enabled && needs_update_today()) {
        g_thread_new("StartupSilentUpdate", silent_update_thread, NULL);
    }

    g_timeout_add_seconds(6 * 60 * 60, auto_update_timer, NULL); // every 6 hours

    gtk_window_present(GTK_WINDOW(app->window));
}

int main(int argc, char **argv) {
    GtkApplication *app = gtk_application_new("com.fyp.antivirus", G_APPLICATION_DEFAULT_FLAGS);
    g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);
    int status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);
    return status;
}